
#This progrom contains several functions in order to manipulate the coins.
#Ziwei Hu 
import random
from coins import *
import doctest


ALPHABET = 'qwertyuiopasdfghjklzxcvbnm1234567890äéèçæœ'
PUNCTUATION = '`~!@#$%^&*()-=_+[]\{}|;\':",./<>? \t\n\r'
ALL_CHARACTERS = ALPHABET + PUNCTUATION
MIN_BASE10_COIN = 0
MAX_BASE10_COIN = 16777215
LETTERS_IN_POPULARITY_ORDER = ' EOTARNLISMHDYFGCWPUBVXK.,\'"-;'


def get_random_comp202coin(index):
    """ (Any) -> str
    Returns a comp202coin generated by converting a random integer,\
    between MIN_BASE10_COIN and MAX_BASE10_COIN.
    
    >>> random.seed(1338)
    >>> get_random_comp202coin(0)
    '0cPMO2C2C0'
    
    >>> get_random_comp202coin(12)
    '0cM2PONOMI'
    
    >>> get_random_comp202coin('youngjack')
    '0cNMONO2NI'
    """
    #generate a random integer between MIN_BASE10_COIN and MAX_BASE10_COIN
    random_int = random.randint(MIN_BASE10_COIN, MAX_BASE10_COIN)
    
    #convert random_int to base 202
    comp202coin = base10_to_202(random_int)
    
    return comp202coin
    
    

def get_random_character(index):
    """ (Any) -> str
    Returns a character at random index of ALL_CHARACTERS
    
    >>> random.seed(1338)
    >>> get_random_character(0)
    '!'
    
    >>> get_random_character(5)
    '9'
    
    >>> random.seed(1206)
    >>> get_random_character('ab')
    '`'
    """
    #generate a random index in ALL_CHARACTERS string
    random_index = random.randint(0, len(ALL_CHARACTERS)-1)

    #get the character at random_index of ALL_CHARACTERS
    character = ALL_CHARACTERS[random_index]
    
    return character
    
    
    
def get_letter_of_popularity_order(index):
    """ (int) -> str
    Returns the character of index from LETTERS_IN_POPULARITY_ORDER.
    If index goes beyond the bounds of the string, return index as a string.
    
    >>> get_letter_of_popularity_order(5)
    'R'
    
    >>> get_letter_of_popularity_order(0)
    ' '
    
    >>> get_letter_of_popularity_order(1229)
    '1229'
    
    >>> get_letter_of_popularity_order(-12)
    Traceback (most recent call last):
    AssertionError: The input should be a non-negative integer.
    
    >>> get_letter_of_popularity_order('12')
    Traceback (most recent call last):
    AssertionError: The input should be a non-negative integer.
    """
    #raise AssertionError if index is not a non-negative integer
    if type(index) != int:
        raise AssertionError("The input should be a non-negative integer.")
    if index < 0:
        raise AssertionError("The input should be a non-negative integer.")
    
    #get the character of index from LETTERS_IN_POPULARITY_ORDER
    if index < 30:
        character = LETTERS_IN_POPULARITY_ORDER[index]
    #return index as a string if index goes beyond the bounds of the string
    else:
        character = str(index)
        
    return character
    
    
    
def get_unique_elements(my_list):
    """ (list) -> list
    Returns a list containing the unique elements of my_list.
    
    >>> get_unique_elements(list('aaaa'))
    ['a']
    
    >>> get_unique_elements([1, 3, 3, 4, 5, 1, 1])
    [1, 3, 4, 5]
    
    >>> get_unique_elements([1, ' ', 1, 'a', ' '])
    [1, ' ', 'a']
    
    >>> get_unique_elements([])
    []
    
    >>> get_unique_elements((1,3,3,4,5,1,1))
    Traceback (most recent call last):
    AssertionError: The input should be a list.
    """
    #raise AssertionError if the input is not a list
    if type(my_list) != list:
        raise AssertionError("The input should be a list.")
    
    #create a new list
    unique_elements_list = []
    
    #iterate through every elements in my_list, add unique element to unique_elements_list
    for element in my_list:
        if element in unique_elements_list:
            continue
        else:
            unique_elements_list.append(element)
            
    return unique_elements_list



def get_all_coins(text):
    """ (str) -> list
    Returns a list of all COMP202COIN found within text, in order of appearance.
    
    >>> get_all_coins("0cCCMMPP22........FEBRUARY 16, 3019..........0cOCOCOCOC.........\
    /FEBRUARY17, 3019..........0C24242412")
    ['0cCCMMPP22', '0cOCOCOCOC']
    
    >>> get_all_coins("0C0C0C0C0C0CCCMMPP22")
    ['0C0C0C0C0C', '0CCCMMPP22']
    
    >>> get_all_coins('abcd1234')
    []
    
    >>> get_all_coins(list("0C0C0C0C0C0CCCMMPP22"))
    Traceback (most recent call last):
    AssertionError: The input should be a string.
    """
    #raise AssertionError if text is not a string
    if type(text) != str:
        raise AssertionError("The input should be a string.")
    
    #create an empty list, iterate through each 10-character in text to check
    #if the 10-character is COMP202COIN, append to the list, skip to the next 10-character
    coin_list = []
    skip_characters = 0
    for i in range(len(text)):
        if i < skip_characters:
            continue
        if is_base202(text[i:i+10]):
            coin_list.append(text[i:i+10])
            skip_characters = i + 10
            
    return coin_list



def reverse_dict(my_dict):
    """ (dict) -> dict
    Returns a new dictionary where the key-value pairs have been flipped.
    my_dict should have unique and immutable values.
    
    >>> a = reverse_dict({'a': 1, 'b': 3, 'd': 7})
    >>> a == {1: 'a', 3: 'b', 7: 'd'}
    True
    
    >>> d = reverse_dict({1: 'a', 2: 'b', 3: 'c'})
    >>> d == {'a': 1, 'b': 2, 'c': 3}
    True
    
    >>> x = reverse_dict({'yj': 1229, 'zw': 1206})
    >>> x == {1229: 'yj', 1206: 'zw'}
    True
    
    >>> b = reverse_dict([('a', 1), ('b', 3), ('d', 7)])
    Traceback (most recent call last):
    AssertionError: The input should be a dictionary.
    
    >>> c = reverse_dict({'a': 8, 'b': 8, 'c': 10})
    Traceback (most recent call last):
    AssertionError: The input dictionary had duplicated values.
    
    >>> e = reverse_dict({'a': [1], 'b': [2, 3]})
    Traceback (most recent call last):
    AssertionError: The input dictionary should have all immutable values.
    """
    #raise AssertionError if my_dict is not a dictionary
    if type(my_dict) != dict:
        raise AssertionError("The input should be a dictionary.")
    
    #raise AssertionError if any value in my_dict is not immutable
    for key in my_dict:
        if type(my_dict[key]) not in (str,int,float,bool,tuple):
            raise AssertionError("The input dictionary should have all immutable values.")
        
    #raise AssertionError if my_dict has duplicated values
    unique_value_list = []
    for key in my_dict:
        if my_dict[key] not in unique_value_list:
            unique_value_list.append(my_dict[key])
        else:
            raise AssertionError("The input dictionary had duplicated values.")
    
    
    #create a new dictionary
    reverse_dictionary = dict()
    
    #add item into reverse_dictionary which flip the key-value pairs in my_dict
    for key in my_dict:
        reverse_dictionary[my_dict[key]] = key
        
    return reverse_dictionary



def get_frequencies(my_list):
    """ (list) -> dict
    Returns a dictionary where each key is an elment of my_list,\
    the corresponding value is the percentage of times that element appears in the list.
    
    >>> x = get_frequencies(['a', 'b', 'c'])
    >>> x == {'a': 0.3333333333333333, 'b': 0.3333333333333333, 'c': 0.3333333333333333}
    True
    
    >>> w = get_frequencies(['a', 2, 3, 'b'])
    >>> w ==  {'a': 0.25, 2: 0.25, 3: 0.25, 'b': 0.25}
    True
    
    >>> z = get_frequencies(['yj', 'zw', 'yj', 'yj'])
    >>> z == {'yj': 0.75, 'zw': 0.25}
    True
    
    >>> v = get_frequencies([])
    >>> v == {}
    True
    
    >>> y = get_frequencies(('a', 'b', 'c'))
    Traceback (most recent call last):
    AssertionError: The input should be a list.
    """
    #raise AssertionError if my_list is not a list
    if type(my_list) != list:
        raise AssertionError("The input should be a list.")
    
    
    #counts how many times each elements appears in the list
    occurrence_dict = {}
    
    for element in my_list:
        if element in occurrence_dict:
            occurrence_dict[element] += 1
        else:
            occurrence_dict[element] = 1
            
    #calculate the total number of element in my_list
    total_element = len(my_list)
    
    #calculate the percentage of of times that element appears in my_list
    for key in occurrence_dict:
        occurrence_dict[key] = occurrence_dict[key] / total_element
        
    return occurrence_dict
    


def sort_keys_by_values(my_dict):
    """ (dict) -> list
    Returns a list of the keys in my_dict, sorted by their values in descending order.
    If two keys have the same value, sort the keys in reverse order.
    
    >>> sort_keys_by_values({'a': 4, 'b': 80, 'c': 1})
    ['b', 'a', 'c']
    
    >>> sort_keys_by_values({'a': 5, 'b': 5, 'c': 5})
    ['c', 'b', 'a']
    
    >>> sort_keys_by_values({})
    []
    
    >>> sort_keys_by_values([('a', 4), ('b', 80), ('c', 1)])
    Traceback (most recent call last):
    AssertionError: The input should be a dictionary.
    
    >>> sort_keys_by_values({'a': '4', 'b': '80', 'c': '1'})
    Traceback (most recent call last):
    AssertionError: The input dictionary should contain all numeric values.
    """
    #raise AssertionError if the input is not a dictionary
    if type(my_dict) != dict:
        raise AssertionError("The input should be a dictionary.")
    
    #raise AssertionError if the input dictionary doesn't contain all numeric values
    for key in my_dict:
        if type(my_dict[key]) not in (int, float):
            raise AssertionError("The input dictionary should contain all numeric values.")

    
    #create a list contains all values in my_dict
    values_list = []
    for key in my_dict:
        values_list.append(my_dict[key])

    #create a list represents the returned list of keys 
    keys_list = []
    
    #while the returned list does not contain all keys in my_dict, keep adding keys
    while len(keys_list) < len(my_dict):
        
        #get the maximum value in values_list, remove all max_value in values_list
        max_value = max(values_list)
        while max_value in values_list:
            values_list.remove(max_value)
        
        #create a list contains all keys in my_dict that its value equals to max_value
        key_max_value = []
        for key in my_dict:
            if my_dict[key] == max_value:
                key_max_value.append(key)
        
        #sort the keys in reverse order
        key_max_value.sort()
        reverse_key = key_max_value[::-1]
        
        #add the keys to the returned list of keys 
        keys_list += reverse_key
        
        
    return keys_list



def swap_letters(s, letter1, letter2):
    """ (str,str,str) -> str
    Returns a string that replaces all instance of letter1 in s by letter2,
    and all instances of letter2 by letter1. The function is case-sensitive.
    
    >>> swap_letters("ABCD abcd", "a", "d")
    'ABCD dbca'
    
    >>> swap_letters("ABCD abcd", "A", "C")
    'CBAD abcd'
    
    >>> swap_letters("ABCD abcd", " ", "A")
    ' BCDAabcd'
    
    >>> swap_letters("ABCD abcd", 1, 2)
    Traceback (most recent call last):
    AssertionError: The input should all be string.
    
    >>> swap_letters("abcd", "ac", "d")
    Traceback (most recent call last):
    AssertionError: The second and the third input should be one character.
    
    >>> swap_letters("abcd", "f", "g")
    Traceback (most recent call last):
    AssertionError: The first input string should contain second and third input.
    """
    #raise AssertionError if any of the input is not a string
    if type(s) != str or type(letter1) != str or type(letter2) != str:
        raise AssertionError("The input should all be string.")
    
    #raise AssertionError if the second and the third input is not one character
    if len(letter1) != 1 or len(letter2) != 1:
        raise AssertionError("The second and the third input should be one character.")
    
    #raise AssertionError if the first input does not contain the second or the third input
    if letter1 not in s or letter2 not in s:
        raise AssertionError("The first input string should contain second and third input.")
    
    
    #create an empty string
    new_string = ""
    
    #iterate through every character, if char is letter1, add letter2 to new_string
    #if char is letter2, add letter1 to new_string, otherwise add char to new_sring
    for char in s:
        if char == letter1:
            new_string += letter2
        elif char == letter2:
            new_string += letter1
        else:
            new_string += char
            
    return new_string
            


def get_pct_common_words(text, common_words_filename):
    """ (str,str) -> float
    Returns the percentage of characters which form part of common words in text.
    
    >>> a = "The quick brown fox jumps over the lazy dog."
    >>> get_pct_common_words(a, 'common_words.txt')
    0.22727272727272727
    
    >>> x = "What are you doing?"
    >>> get_pct_common_words(x, 'common_words.txt')
    0.7894736842105263
    
    >>> y = "I really: like,myself, what(about you?"
    >>> get_pct_common_words(y, 'common_words.txt')
    0.47368421052631576
    
    >>> c = "   "
    >>> get_pct_common_words(c, 'common_words.txt')
    0.0
    
    >>> b = 125
    >>> get_pct_common_words(b, 'common_words.txt')
    Traceback (most recent call last):
    AssertionError: The input should be string.
    """
    #raise AssertionError if the input is not a string
    if type(text) != str or type(common_words_filename) != str:
        raise AssertionError("The input should be string.")
    
    
    #create a new text with all punctuation in text replace by a blank
    new_text = ""
    for char in text:
        if char in PUNCTUATION:
            new_text += " "
        else:
            new_text += char.lower()
    
    #split each word in new_text into a list
    words_list = new_text.split()
    
    #if no word in words_list, the percentage should be 0.0
    if len(words_list) == 0:
        return 0.0
   
   
    #open the input file, retrive the file content, close the file
    file_object = open(common_words_filename, 'r', encoding = 'utf-8')
    
    #iterate through words_list, count the number of words appear in file_content
    num_common_char = 0
    for line in file_object:
        for element in words_list:
            if element == line.strip():
                num_common_char += len(element)
                
    file_object.close()
            
            
    #calculate the percentage of common words
    pct_common_words = num_common_char / len(text)
    
    return pct_common_words
            
    
    
if __name__ == "__main__":
    doctest.testmod()
    
#This progrom contains several functions in order to manipulate the coins.
#Ziwei Hu 260889365
import random
from coins import *
import doctest
 
 
ALPHABET = 'qwertyuiopasdfghjklzxcvbnm1234567890äéèçæœ'
PUNCTUATION = '`~!@#$%^&*()-=_+[]\{}|;\':",./<>? \t\n\r'
ALL_CHARACTERS = ALPHABET + PUNCTUATION
MIN_BASE10_COIN = 0
MAX_BASE10_COIN = 16777215
LETTERS_IN_POPULARITY_ORDER = ' EOTARNLISMHDYFGCWPUBVXK.,\'"-;'
 
 
def get_random_comp202coin(index):
    """ (Any) -> str
    Returns a comp202coin generated by converting a random integer,\
    between MIN_BASE10_COIN and MAX_BASE10_COIN.
    
    >>> random.seed(1338)
    >>> get_random_comp202coin(0)
    '0cPMO2C2C0'
    
    >>> get_random_comp202coin(12)
    '0cM2PONOMI'
    
    >>> get_random_comp202coin('youngjack')
    '0cNMONO2NI'
    """
    #generate a random integer between MIN_BASE10_COIN and MAX_BASE10_COIN
    random_int = random.randint(MIN_BASE10_COIN, MAX_BASE10_COIN)
    
    #convert random_int to base 202
    comp202coin = base10_to_202(random_int)
    
    return comp202coin
    
    
 
def get_random_character(index):
    """ (Any) -> str
    Returns a character at random index of ALL_CHARACTERS
    
    >>> random.seed(1338)
    >>> get_random_character(0)
    '!'
    
    >>> get_random_character(5)
    '9'
    
    >>> random.seed(1206)
    >>> get_random_character('ab')
    '`'
    """
    #generate a random index in ALL_CHARACTERS string
    random_index = random.randint(0, len(ALL_CHARACTERS)-1)
 
    #get the character at random_index of ALL_CHARACTERS
    character = ALL_CHARACTERS[random_index]
    
    return character
    
    
    
def get_letter_of_popularity_order(index):
    """ (int) -> str
    Returns the character of index from LETTERS_IN_POPULARITY_ORDER.
    If index goes beyond the bounds of the string, return index as a string.
    
    >>> get_letter_of_popularity_order(5)
    'R'
    
    >>> get_letter_of_popularity_order(0)
    ' '
    
    >>> get_letter_of_popularity_order(1229)
    '1229'
    
    >>> get_letter_of_popularity_order(-12)
    Traceback (most recent call last):
    AssertionError: The input should be a non-negative integer.
    
    >>> get_letter_of_popularity_order('12')
    Traceback (most recent call last):
    AssertionError: The input should be a non-negative integer.
    """
    #raise AssertionError if index is not a non-negative integer
    if type(index) != int:
        raise AssertionError("The input should be a non-negative integer.")
    if index < 0:
        raise AssertionError("The input should be a non-negative integer.")
    
    #get the character of index from LETTERS_IN_POPULARITY_ORDER
    if index < 30:
        character = LETTERS_IN_POPULARITY_ORDER[index]
    #return index as a string if index goes beyond the bounds of the string
    else:
        character = str(index)
        
    return character
    
    
    
def get_unique_elements(my_list):
    """ (list) -> list
    Returns a list containing the unique elements of my_list.
    
    >>> get_unique_elements(list('aaaa'))
    ['a']
    
    >>> get_unique_elements([1, 3, 3, 4, 5, 1, 1])
    [1, 3, 4, 5]
    
    >>> get_unique_elements([1, ' ', 1, 'a', ' '])
    [1, ' ', 'a']
    
    >>> get_unique_elements([])
    []
    
    >>> get_unique_elements((1,3,3,4,5,1,1))
    Traceback (most recent call last):
    AssertionError: The input should be a list.
    """
    #raise AssertionError if the input is not a list
    if type(my_list) != list:
        raise AssertionError("The input should be a list.")
    
    #create a new list
    unique_elements_list = []
    
    #iterate through every elements in my_list, add unique element to unique_elements_list
    for element in my_list:
        if element in unique_elements_list:
            continue
        else:
            unique_elements_list.append(element)
            
    return unique_elements_list
 
 
 
def get_all_coins(text):
    """ (str) -> list
    Returns a list of all COMP202COIN found within text, in order of appearance.
    
    >>> get_all_coins("0cCCMMPP22........FEBRUARY 16, 3019..........0cOCOCOCOC.........\
    /FEBRUARY17, 3019..........0C24242412")
    ['0cCCMMPP22', '0cOCOCOCOC']
    
    >>> get_all_coins("0C0C0C0C0C0CCCMMPP22")
    ['0C0C0C0C0C', '0CCCMMPP22']
    
    >>> get_all_coins('abcd1234')
    []
    
    >>> get_all_coins(list("0C0C0C0C0C0CCCMMPP22"))
    Traceback (most recent call last):
    AssertionError: The input should be a string.
    """
    #raise AssertionError if text is not a string
    if type(text) != str:
        raise AssertionError("The input should be a string.")
    
    #create an empty list, iterate through each 10-character in text to check
    #if the 10-character is COMP202COIN, append to the list, skip to the next 10-character
    coin_list = []
    skip_characters = 0
    for i in range(len(text)):
        if i < skip_characters:
            continue
        if is_base202(text[i:i+10]):
            coin_list.append(text[i:i+10])
            skip_characters = i + 10
            
    return coin_list
 
 
 
def reverse_dict(my_dict):
    """ (dict) -> dict
    Returns a new dictionary where the key-value pairs have been flipped.
    my_dict should have unique and immutable values.
    
    >>> a = reverse_dict({'a': 1, 'b': 3, 'd': 7})
    >>> a == {1: 'a', 3: 'b', 7: 'd'}
    True
    
    >>> d = reverse_dict({1: 'a', 2: 'b', 3: 'c'})
    >>> d == {'a': 1, 'b': 2, 'c': 3}
    True
    
    >>> x = reverse_dict({'yj': 1229, 'zw': 1206})
    >>> x == {1229: 'yj', 1206: 'zw'}
    True
    
    >>> b = reverse_dict([('a', 1), ('b', 3), ('d', 7)])
    Traceback (most recent call last):
    AssertionError: The input should be a dictionary.
    
    >>> c = reverse_dict({'a': 8, 'b': 8, 'c': 10})
    Traceback (most recent call last):
    AssertionError: The input dictionary had duplicated values.
    
    >>> e = reverse_dict({'a': [1], 'b': [2, 3]})
    Traceback (most recent call last):
    AssertionError: The input dictionary should have all immutable values.
    """
    #raise AssertionError if my_dict is not a dictionary
    if type(my_dict) != dict:
        raise AssertionError("The input should be a dictionary.")
    
    #raise AssertionError if any value in my_dict is not immutable
    for key in my_dict:
        if type(my_dict[key]) not in (str,int,float,bool,tuple):
            raise AssertionError("The input dictionary should have all immutable values.")
        
    #raise AssertionError if my_dict has duplicated values
    unique_value_list = []
    for key in my_dict:
        if my_dict[key] not in unique_value_list:
            unique_value_list.append(my_dict[key])
        else:
            raise AssertionError("The input dictionary had duplicated values.")
    
    
    #create a new dictionary
    reverse_dictionary = dict()
    
    #add item into reverse_dictionary which flip the key-value pairs in my_dict
    for key in my_dict:
        reverse_dictionary[my_dict[key]] = key
        
    return reverse_dictionary
 
 
 
def get_frequencies(my_list):
    """ (list) -> dict
    Returns a dictionary where each key is an elment of my_list,\
    the corresponding value is the percentage of times that element appears in the list.
    
    >>> x = get_frequencies(['a', 'b', 'c'])
    >>> x == {'a': 0.3333333333333333, 'b': 0.3333333333333333, 'c': 0.3333333333333333}
    True
    
    >>> w = get_frequencies(['a', 2, 3, 'b'])
    >>> w ==  {'a': 0.25, 2: 0.25, 3: 0.25, 'b': 0.25}
    True
    
    >>> z = get_frequencies(['yj', 'zw', 'yj', 'yj'])
    >>> z == {'yj': 0.75, 'zw': 0.25}
    True
    
    >>> v = get_frequencies([])
    >>> v == {}
    True
    
    >>> y = get_frequencies(('a', 'b', 'c'))
    Traceback (most recent call last):
    AssertionError: The input should be a list.
    """
    #raise AssertionError if my_list is not a list
    if type(my_list) != list:
        raise AssertionError("The input should be a list.")
    
    
    #counts how many times each elements appears in the list
    occurrence_dict = {}
    
    for element in my_list:
        if element in occurrence_dict:
            occurrence_dict[element] += 1
        else:
            occurrence_dict[element] = 1
            
    #calculate the total number of element in my_list
    total_element = len(my_list)
    
    #calculate the percentage of of times that element appears in my_list
    for key in occurrence_dict:
        occurrence_dict[key] = occurrence_dict[key] / total_element
        
    return occurrence_dict
    
 
 
def sort_keys_by_values(my_dict):
    """ (dict) -> list
    Returns a list of the keys in my_dict, sorted by their values in descending order.
    If two keys have the same value, sort the keys in reverse order.
    
    >>> sort_keys_by_values({'a': 4, 'b': 80, 'c': 1})
    ['b', 'a', 'c']
    
    >>> sort_keys_by_values({'a': 5, 'b': 5, 'c': 5})
    ['c', 'b', 'a']
    
    >>> sort_keys_by_values({})
    []
    
    >>> sort_keys_by_values([('a', 4), ('b', 80), ('c', 1)])
    Traceback (most recent call last):
    AssertionError: The input should be a dictionary.
    
    >>> sort_keys_by_values({'a': '4', 'b': '80', 'c': '1'})
    Traceback (most recent call last):
    AssertionError: The input dictionary should contain all numeric values.
    """
    #raise AssertionError if the input is not a dictionary
    if type(my_dict) != dict:
        raise AssertionError("The input should be a dictionary.")
    
    #raise AssertionError if the input dictionary doesn't contain all numeric values
    for key in my_dict:
        if type(my_dict[key]) not in (int, float):
            raise AssertionError("The input dictionary should contain all numeric values.")
 
    
    #create a list contains all values in my_dict
    values_list = []
    for key in my_dict:
        values_list.append(my_dict[key])
 
    #create a list represents the returned list of keys 
    keys_list = []
    
    #while the returned list does not contain all keys in my_dict, keep adding keys
    while len(keys_list) < len(my_dict):
        
        #get the maximum value in values_list, remove all max_value in values_list
        max_value = max(values_list)
        while max_value in values_list:
            values_list.remove(max_value)
        
        #create a list contains all keys in my_dict that its value equals to max_value
        key_max_value = []
        for key in my_dict:
            if my_dict[key] == max_value:
                key_max_value.append(key)
        
        #sort the keys in reverse order
        key_max_value.sort()
        reverse_key = key_max_value[::-1]
        
        #add the keys to the returned list of keys 
        keys_list += reverse_key
        
        
    return keys_list
 
 
 
def swap_letters(s, letter1, letter2):
    """ (str,str,str) -> str
    Returns a string that replaces all instance of letter1 in s by letter2,
    and all instances of letter2 by letter1. The function is case-sensitive.
    
    >>> swap_letters("ABCD abcd", "a", "d")
    'ABCD dbca'
    
    >>> swap_letters("ABCD abcd", "A", "C")
    'CBAD abcd'
    
    >>> swap_letters("ABCD abcd", " ", "A")
    ' BCDAabcd'
    
    >>> swap_letters("ABCD abcd", 1, 2)
    Traceback (most recent call last):
    AssertionError: The input should all be string.
    
    >>> swap_letters("abcd", "ac", "d")
    Traceback (most recent call last):
    AssertionError: The second and the third input should be one character.
    
    >>> swap_letters("abcd", "f", "g")
    Traceback (most recent call last):
    AssertionError: The first input string should contain second and third input.
    """
    #raise AssertionError if any of the input is not a string
    if type(s) != str or type(letter1) != str or type(letter2) != str:
        raise AssertionError("The input should all be string.")
    
    #raise AssertionError if the second and the third input is not one character
    if len(letter1) != 1 or len(letter2) != 1:
        raise AssertionError("The second and the third input should be one character.")
    
    #raise AssertionError if the first input does not contain the second or the third input
    if letter1 not in s or letter2 not in s:
        raise AssertionError("The first input string should contain second and third input.")
    
    
    #create an empty string
    new_string = ""
    
    #iterate through every character, if char is letter1, add letter2 to new_string
    #if char is letter2, add letter1 to new_string, otherwise add char to new_sring
    for char in s:
        if char == letter1:
            new_string += letter2
        elif char == letter2:
            new_string += letter1
        else:
            new_string += char
            
    return new_string
            
 
 
def get_pct_common_words(text, common_words_filename):
    """ (str,str) -> float
    Returns the percentage of characters which form part of common words in text.
    
    >>> a = "The quick brown fox jumps over the lazy dog."
    >>> get_pct_common_words(a, 'common_words.txt')
    0.22727272727272727
    
    >>> x = "What are you doing?"
    >>> get_pct_common_words(x, 'common_words.txt')
    0.7894736842105263
    
    >>> y = "I really: like,myself, what(about you?"
    >>> get_pct_common_words(y, 'common_words.txt')
    0.47368421052631576
    
    >>> c = "   "
    >>> get_pct_common_words(c, 'common_words.txt')
    0.0
    
    >>> b = 125
    >>> get_pct_common_words(b, 'common_words.txt')
    Traceback (most recent call last):
    AssertionError: The input should be string.
    """
    #raise AssertionError if the input is not a string
    if type(text) != str or type(common_words_filename) != str:
        raise AssertionError("The input should be string.")
    
    
    #create a new text with all punctuation in text replace by a blank
    new_text = ""
    for char in text:
        if char in PUNCTUATION:
            new_text += " "
        else:
            new_text += char.lower()
    
    #split each word in new_text into a list
    words_list = new_text.split()
    
    #if no word in words_list, the percentage should be 0.0
    if len(words_list) == 0:
        return 0.0
   
   
    #open the input file, retrive the file content, close the file
    file_object = open(common_words_filename, 'r', encoding = 'utf-8')
    
    #iterate through words_list, count the number of words appear in file_content
    num_common_char = 0
    for line in file_object:
        for element in words_list:
            if element == line.strip():
                num_common_char += len(element)
                
    file_object.close()
            
            
    #calculate the percentage of common words
    pct_common_words = num_common_char / len(text)
    
    return pct_common_words
            
    
    
if __name__ == "__main__":
    doctest.testmod()